<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>N-Queens Problem - CodeDSA</title>
  <link rel="stylesheet" href="../../CSS/AllProblems.css">
  <link rel="stylesheet" href="../../CSS/breadcrumb.css">
  <link rel="stylesheet" href="../../CSS/snake.css">
</head>
<body>

  <nav class="navbar">
    <div class="logo">CodeDSA</div>
    <div class="nav-right">
    <ul class="nav-links">
      <li><a href="../../index.html">Home</a></li>
      <li><a href="../../about.html">About</a></li>
      <li><a href="../../contact.html">Contact</a></li>
    </ul>
    <button id="snakeToggle" class="snake-btn"><span style="margin-left: 20px;">Snake Cursor</span></button>
    <button id="darkModeToggle" class="dark-mode-btn">ðŸŒ™ Dark Mode</button>
    </div>
  </nav>

  <div class="breadcrumb-container">
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="../../index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="../Backtracking.html">Backtracking</a></li>
        <li class="breadcrumb-item active" aria-current="page">N-Queens Problem</li>
      </ol>
    </nav>
  </div>

  <main>
    <h1>N-Queens Problem</h1>

    <section class="problem-section">
      <h2>Problem Statement</h2>
      <p>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer <strong>n</strong>, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.</p>
      <p><strong>Example:</strong> Input: n = 4 â†’ Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]</p>
    </section>

    <section class="approach-section">
      <h2>Approach 1: Simple Backtracking</h2>
      <p><strong>Explanation (Brute):</strong> We try to place one queen in each row. We define a recursive function that takes the current row number as an argument. In that row, we iterate through each column. For each column, we place a queen and then check if this placement is valid by scanning the entire board to see if it conflicts with any previously placed queens. If valid, we recurse for the next row. If not, we backtrack.</p>
      <p><strong>Time Complexity:</strong> O(N!), as we have N choices for the first row, N-1 for the second, and so on.</p>
      <p><strong>Space Complexity:</strong> O(N*N) for the board and recursion stack.</p>
      <pre class="pseudo-code">
function solveNQueens(n):
    board = create empty n*n board
    result = []
    backtrack(result, board, 0) // Start from row 0
    return result

function backtrack(result, board, row):
    if row == n:
        add formatted board to result
        return
    for col from 0 to n-1:
        if is_valid(board, row, col):
            board[row][col] = 'Q'
            backtrack(result, board, row + 1)
            board[row][col] = '.' // Backtrack
      </pre>
    </section>

    <section class="approach-section">
      <h2>Approach 2: Backtracking with O(1) Validity Check</h2>
      <p><strong>Explanation (Better/Optimal):</strong> The `is_valid` check in the brute-force approach is inefficient. We can optimize it to O(1) by using extra space. We maintain sets or boolean arrays to track occupied columns, positive diagonals (row-col), and negative diagonals (row+col). When we try to place a queen at `(row, col)`, we just check these sets. If the column or diagonals are already occupied, it's an invalid move. This is the standard and efficient way to solve this problem.</p>
      <p><strong>Time Complexity:</strong> O(N!)</p>
      <p><strong>Space Complexity:</strong> O(N*N) for the board + O(N) for the tracking sets.</p>
      <pre class="pseudo-code">
// Initialize sets for columns, positive diagonals, and negative diagonals
occupied_cols = set()
occupied_pos_diags = set() // where value is (row - col)
occupied_neg_diags = set() // where value is (row + col)

function backtrack(result, board, row):
    if row == n: ...
    for col from 0 to n-1:
        if col in occupied_cols or (row-col) in occupied_pos_diags or (row+col) in occupied_neg_diags:
            continue // Invalid placement
        
        // Place queen and update sets
        place_queen(row, col)
        backtrack(result, board, row + 1)
        // Remove queen and update sets (backtrack)
        remove_queen(row, col)
      </pre>
    </section>

    <section class="approach-section">
      <h2>Approach 3: Bitmasking</h2>
      <p><strong>Explanation (Advanced):</strong> For boards up to N=32 or N=64, bitmasking can offer a highly optimized version of the O(1) validity check. We can use integers as bitmasks to represent the occupied columns and diagonals. Placing a queen and checking for validity becomes a series of fast bitwise operations (AND, OR, XOR, bit shifts). This is a more advanced technique that reduces the memory overhead and can be faster, but it's less intuitive than using sets.</p>
      <p><strong>Time Complexity:</strong> O(N!)</p>
      <p><strong>Space Complexity:</strong> O(N) for the recursion stack.</p>
      <pre class="pseudo-code">
// Instead of sets, use integer bitmasks
// col_mask, pos_diag_mask, neg_diag_mask

function backtrack(row, col_mask, pos_diag_mask, neg_diag_mask):
    if row == n: ...
    // Find all available positions in the current row
    available_positions = ((1 << n) - 1) & ~(col_mask | pos_diag_mask | neg_diag_mask)
    while available_positions > 0:
        // Get the least significant bit
        position = available_positions & -available_positions
        // Remove it from available positions
        available_positions &= ~position
        // Recurse with updated masks
      </pre>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Mrunalini Pachpute. All rights reserved.</p>
  </footer>
  <script src="../../index.js"></script>
</body>
</html>